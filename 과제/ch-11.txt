병합(merge)
 fast-forward(빨리 감기) 병합
 3-awy 병합

fast-forward 병합 조건
현재 브랜치 master가 병합할 대상 커밋의 직접적인 뿌리(조상)가 되는 경우

브랜치 master에서 병합 명령
$ git merge bugfix
master 브랜치는 단순히 이동

3-way 상태: 두 분기가 갈라진 상태
두 브랜치의 조상이 같은 경우
master 브랜치 내의 변경 내용과 bugfix 브랜치 내의 변경 내용을 하나로 통합할 필요

3-way 병합(옵션 --no-ff)
새로운 커밋을 사용하여 두 기록을 합침
두 브랜치의 변경을 가져온 'merge commit(병합 커밋)‘ E를 생성
병합 완료 후, 통합 브랜치인 'master' 브랜치로 통합된 이력이 생성
-m이 없으면 메시지 입력할 기본 편집기 실행
‘Merge branch bugfix’이 기본 메시지 내용

non fast-forward 병합
$ git merge --no-ff {병합할 브랜치 명}
병합 실행 시에 'fast-forward 병합'이 가능한 경우라도 3-way 병합을 수행
병합된 브랜치가 그대로 남기 때문에
그 브랜치로 실행한 작업 확인 및 브랜치 관리 면에서 더 유용

$ git merge {병합할 브랜치 명}
보통의 병합, 융통성 있는 병합

현 브랜치와 병합할 브랜치가 일렬 상태
fast-forward 병합
새로운 병합 커밋 없이 병합할 브랜치 커밋으로 이동

현 브랜치와 병합할 브랜치가 갈라져 있는 상태
3-way 병합
새로운 병합 커밋을 생성해 두 브랜치를 합침

$ git merge --no-ff {병합할_브랜치_명}
무조건 3-way 병합되는 옵션

$ git merge --ff-only {병합할_브랜치_명}
상태가 fast-Forward인 일렬 상태에서만 병합 진행

$ git merge --squash {병합할_브랜치_명}
현재 브랜치에 병합 대상과의 합치는 커밋을 하나 생성해 병합
병합되는 브랜치는 사용하지 않고 그대로 남음

강압적인 병합
$ git merge --squash hotfix
커밋 이력과 병합되는 브랜치 이력도 남기지 않음
새로운 커밋에 상대 브랜치의 내용을 모두 합해 새로운 커밋으로 병합
직접 메시지와 함께 커밋을 해야 함

<충돌의 기준>
파일 충돌 없음
수정되지 않거나 한쪽 브랜치에서만 수정되면

파일 충돌 발생
두 브랜치 모두에서 변경 사항이 달리 발생한 파일

충돌 해결
계속해서 add, commit 진행
직접 파일 내용을 수정 후 저장
필요하면 합병된 이전 브랜치 삭제

충돌한 파일 내부 표시
3개의 표시로 구분
<<<<<<< HEAD
현재 브랜치 HEAD의 수정 내용
=========== 
병합되는 브랜치 feat/list의 수정 내용
>>>>>>> feat/list

병합 취소
$ git merge --abort 

다시 병합
$ git merge feat/list



















